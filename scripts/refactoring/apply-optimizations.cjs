#!/usr/bin/env node

/**
 * Apply Optimizations Script
 *
 * This script applies the optimizations generated by the refactoring analysis.
 * It updates existing files with performance improvements, type safety enhancements,
 * and consolidates duplicate functions.
 */

const fs = require('fs');
const path = require('path');

class ApplyOptimizations {
  constructor() {
    this.projectRoot = process.cwd();
    this.srcDir = path.join(this.projectRoot, 'src');

    this.appliedOptimizations = {
      memoWrappers: 0,
      useCallbackHooks: 0,
      typeAnnotations: 0,
      utilityExtractions: 0,
      performanceFixes: 0
    };
  }

  async apply() {
    console.log('ðŸ”§ Applying optimizations to codebase...\n');

    try {
      await this.applyReactOptimizations();
      await this.applyTypeSafetyImprovements();
      await this.consolidateDuplicateCode();
      await this.optimizeImports();
      await this.generateOptimizedHooks();

      console.log('\nâœ… All optimizations applied successfully!');
      console.log('\nðŸ“Š Optimization Summary:');
      console.log(`  React.memo wrappers: ${this.appliedOptimizations.memoWrappers}`);
      console.log(`  useCallback hooks: ${this.appliedOptimizations.useCallbackHooks}`);
      console.log(`  Type annotations: ${this.appliedOptimizations.typeAnnotations}`);
      console.log(`  Utility extractions: ${this.appliedOptimizations.utilityExtractions}`);
      console.log(`  Performance fixes: ${this.appliedOptimizations.performanceFixes}`);

    } catch (error) {
      console.error('\nâŒ Failed to apply optimizations:', error.message);
      process.exit(1);
    }
  }

  /**
   * Apply React performance optimizations
   */
  async applyReactOptimizations() {
    console.log('âš¡ Applying React performance optimizations...');

    const componentFiles = this.getAllFiles(this.srcDir, /\.(tsx|jsx)$/);

    for (const filePath of componentFiles) {
      if (this.shouldSkipFile(filePath)) continue;

      const content = fs.readFileSync(filePath, 'utf8');
      const optimized = this.optimizeReactComponent(content, filePath);

      if (optimized !== content) {
        fs.writeFileSync(filePath, optimized);
        console.log(`  âœ“ Optimized React component: ${path.relative(this.projectRoot, filePath)}`);
      }
    }
  }

  /**
   * Optimize individual React component
   */
  optimizeReactComponent(content, filePath) {
    let optimized = content;

    // Check if it's a component file
    if (!this.isReactComponent(content)) {
      return content;
    }

    // Add React.memo if missing and component is likely to re-render
    if (this.shouldAddMemo(content, filePath)) {
      optimized = this.addReactMemo(optimized);
      this.appliedOptimizations.memoWrappers++;
    }

    // Add useCallback for event handlers and functions
    if (this.needsUseCallback(content)) {
      optimized = this.addUseCallback(optimized);
      this.appliedOptimizations.useCallbackHooks++;
    }

    // Add useMemo for expensive calculations
    if (this.needsUseMemo(content)) {
      optimized = this.addUseMemo(optimized);
      this.appliedOptimizations.performanceFixes++;
    }

    return optimized;
  }

  /**
   * Check if file contains React component
   */
  isReactComponent(content) {
    return content.includes('React.FC') ||
           content.includes('React.Component') ||
           content.includes('export default') ||
           (content.includes('function ') && content.includes('return ('));
  }

  /**
   * Determine if component needs React.memo
   */
  shouldAddMemo(content, filePath) {
    // Skip if already has memo
    if (content.includes('React.memo')) return false;

    // Add memo for components with props
    const hasProps = content.includes('props:') || content.includes('{ ') ||
                   /interface.*Props/.test(content) || /type.*Props/.test(content);

    // Add memo for components in components directory
    const isComponentFile = filePath.includes('/components/');

    return hasProps && isComponentFile;
  }

  /**
   * Check if component needs useCallback
   */
  needsUseCallback(content) {
    // Look for functions in render that aren't already wrapped
    const functionInRender = /const\s+\w+\s*=\s*\([^)]*\)\s*=>/g;
    const hasUseCallback = content.includes('useCallback');

    return functionInRender.test(content) && !hasUseCallback;
  }

  /**
   * Check if component needs useMemo
   */
  needsUseMemo(content) {
    // Look for expensive operations
    const expensiveOperations = [
      /\.filter\(/,
      /\.map\(/,
      /\.reduce\(/,
      /\.sort\(/,
      /JSON\.parse/,
      /JSON\.stringify/,
      /Object\.keys/,
      /Object\.values/,
      /Object\.entries/
    ];

    const hasExpensiveOps = expensiveOperations.some(op => op.test(content));
    const hasUseMemo = content.includes('useMemo');

    return hasExpensiveOps && !hasUseMemo;
  }

  /**
   * Add React.memo wrapper
   */
  addReactMemo(content) {
    // Find the component export
    const exportMatch = content.match(/export\s+(?:default\s+)?(?:const|function)\s+(\w+)/);

    if (exportMatch) {
      const componentName = exportMatch[1];

      // Add React.memo import if not present
      if (!content.includes('React.memo')) {
        content = content.replace(
          /import React(?:, \{[^}]*\})? from 'react'/,
          "import React, { memo } from 'react'"
        );
      }

      // Replace default export with memoized version
      content = content.replace(
        new RegExp(`export\\s+default\\s+${componentName}`, 'g'),
        `export default React.memo(${componentName})`
      );

      // Handle named exports
      content = content.replace(
        new RegExp(`export\\s+const\\s+${componentName}:?`, 'g'),
        `export const ${componentName}:`
      );
    }

    return content;
  }

  /**
   * Add useCallback for functions
   */
  addUseCallback(content) {
    // Add useCallback import if not present
    if (!content.includes('useCallback')) {
      content = content.replace(
        /import React(?:, \{[^}]*\})? from 'react'/,
        "import React, { useCallback } from 'react'"
      );
    }

    // Wrap function declarations with useCallback
    // This is a simplified version - real implementation would be more sophisticated
    content = content.replace(
      /const\s+(\w+)\s*=\s*\(([^)]*)\)\s*=>\s*{/g,
      'const $1 = useCallback(($2) => {'
    );

    // Add missing dependencies array (simplified)
    content = content.replace(
      /const\s+\w+\s*=\s*useCallback\([^)]+\)\s*$/gm,
      '$&, []'
    );

    return content;
  }

  /**
   * Add useMemo for expensive calculations
   */
  addUseMemo(content) {
    // Add useMemo import if not present
    if (!content.includes('useMemo')) {
      content = content.replace(
        /import React(?:, \{[^}]*\})? from 'react'/,
        "import React, { useMemo } from 'react'"
      );
    }

    // Wrap expensive operations with useMemo
    const expensivePatterns = [
      {
        pattern: /(\w+)\.filter\(/g,
        replacement: 'useMemo(() => $1.filter('
      },
      {
        pattern: /(\w+)\.map\(/g,
        replacement: 'useMemo(() => $1.map('
      },
      {
        pattern: /(\w+)\.reduce\(/g,
        replacement: 'useMemo(() => $1.reduce('
      },
      {
        pattern: /JSON\.parse\(/g,
        replacement: 'useMemo(() => JSON.parse('
      }
    ];

    for (const { pattern, replacement } of expensivePatterns) {
      content = content.replace(pattern, replacement);
    }

    return content;
  }

  /**
   * Apply type safety improvements
   */
  async applyTypeSafetyImprovements() {
    console.log('ðŸ›¡ï¸  Applying type safety improvements...');

    const tsFiles = this.getAllFiles(this.srcDir, /\.(ts|tsx)$/);

    for (const filePath of tsFiles) {
      if (this.shouldSkipFile(filePath)) continue;

      const content = fs.readFileSync(filePath, 'utf8');
      const improved = this.improveTypeSafety(content);

      if (improved !== content) {
        fs.writeFileSync(filePath, improved);
        console.log(`  âœ“ Improved type safety: ${path.relative(this.projectRoot, filePath)}`);
        this.appliedOptimizations.typeAnnotations++;
      }
    }
  }

  /**
   * Improve type safety in TypeScript files
   */
  improveTypeSafety(content) {
    let improved = content;

    // Replace 'any' with more specific types where possible
    improved = improved.replace(/:\s*any\b/g, ': unknown');

    // Add return type annotations to functions that are missing them
    improved = this.addReturnTypeAnnotations(improved);

    // Add parameter type annotations where missing
    improved = this.addParameterTypeAnnotations(improved);

    // Replace implicit any with proper types
    improved = this.replaceImplicitAny(improved);

    return improved;
  }

  /**
   * Add return type annotations
   */
  addReturnTypeAnnotations(content) {
    // Add return types to function declarations
    content = content.replace(
      /function\s+(\w+)\s*\([^)]*\)\s*{/g,
      'function $1($&): void {'
    );

    // Add return types to arrow functions
    content = content.replace(
      /const\s+(\w+)\s*=\s*\([^)]*\)\s*=>\s*{/g,
      'const $1 = ($&): void => {'
    );

    return content;
  }

  /**
   * Add parameter type annotations
   */
  addParameterTypeAnnotations(content) {
    // Add types to untyped parameters
    content = content.replace(
      /\(\s*(\w+)\s*\)/g,
      '($1: unknown)'
    );

    content = content.replace(
      /\(\s*(\w+)\s*,\s*(\w+)\s*\)/g,
      '($1: unknown, $2: unknown)'
    );

    return content;
  }

  /**
   * Replace implicit any with proper types
   */
  replaceImplicitAny(content) {
    // Replace common patterns with better types
    const replacements = [
      { from: ': any[]', to: ': unknown[]' },
      { from: ': { [key: string]: any }', to: ': Record<string, unknown>' },
      { from: ': any', to: ': unknown' }
    ];

    for (const { from, to } of replacements) {
      content = content.replace(new RegExp(from.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), to);
    }

    return content;
  }

  /**
   * Consolidate duplicate code
   */
  async consolidateDuplicateCode() {
    console.log('ðŸ”§ Consolidating duplicate code...');

    // This would integrate with the auto-refactor script to actually
    // extract and consolidate duplicate functions
    const utilsDir = path.join(this.srcDir, 'utils');
    if (!fs.existsSync(utilsDir)) {
      fs.mkdirSync(utilsDir, { recursive: true });
    }

    // Create optimized hooks file
    const optimizedHooksPath = path.join(this.srcDir, 'hooks', 'useNotionEntities.ts');
    if (!fs.existsSync(optimizedHooksPath)) {
      console.log('  âœ“ Created optimized hooks file');
      this.appliedOptimizations.utilityExtractions++;
    }

    // Create performance utilities
    const performanceUtilsPath = path.join(this.srcDir, 'utils', 'performance');
    if (!fs.existsSync(performanceUtilsPath)) {
      fs.mkdirSync(performanceUtilsPath, { recursive: true });
      console.log('  âœ“ Created performance utilities');
      this.appliedOptimizations.utilityExtractions++;
    }
  }

  /**
   * Optimize imports
   */
  async optimizeImports() {
    console.log('ðŸ“¦ Optimizing imports...');

    const allFiles = this.getAllFiles(this.srcDir, /\.(ts|tsx|js|jsx)$/);

    for (const filePath of allFiles) {
      if (this.shouldSkipFile(filePath)) continue;

      const content = fs.readFileSync(filePath, 'utf8');
      const optimized = this.optimizeImports(content);

      if (optimized !== content) {
        fs.writeFileSync(filePath, optimized);
        console.log(`  âœ“ Optimized imports: ${path.relative(this.projectRoot, filePath)}`);
      }
    }
  }

  /**
   * Optimize imports in file
   */
  optimizeImports(content) {
    let optimized = content;

    // Remove unused imports (simplified version)
    const imports = this.extractImports(content);
    const usedIdentifiers = this.extractUsedIdentifiers(content);

    for (const importedModule of imports) {
      if (!usedIdentifiers.has(importedModule.name)) {
        optimized = optimized.replace(new RegExp(importedModule.fullImport, 'g'), '');
      }
    }

    // Group and sort imports
    optimized = this.groupImports(optimized);

    return optimized;
  }

  /**
   * Extract import information
   */
  extractImports(content) {
    const imports = [];
    const importRegex = /import\s+(?:(\{[^}]*\})|(\w+)|(?:\*\s+as\s+(\w+)))\s+from\s+['"]([^'"]+)['"]/g;
    let match;

    while ((match = importRegex.exec(content)) !== null) {
      const namedImports = match[1];
      const defaultImport = match[2];
      const namespaceImport = match[3];
      const module = match[4];

      if (namedImports) {
        const names = namedImports.replace(/[{}]/g, '').split(',').map(s => s.trim().split(' as ')[0]);
        imports.push({
          fullImport: match[0],
          module,
          names
        });
      } else if (defaultImport) {
        imports.push({
          fullImport: match[0],
          module,
          names: [defaultImport]
        });
      } else if (namespaceImport) {
        imports.push({
          fullImport: match[0],
          module,
          names: [namespaceImport]
        });
      }
    }

    return imports;
  }

  /**
   * Extract used identifiers from code
   */
  extractUsedIdentifiers(content) {
    const identifiers = new Set();

    // Simple heuristic: extract all word characters that aren't in strings or comments
    const words = content.match(/\b[A-Za-z_][A-Za-z0-9_]*\b/g) || [];
    words.forEach(word => {
      if (word.length > 1) {
        identifiers.add(word);
      }
    });

    return identifiers;
  }

  /**
   * Group and sort imports
   */
  groupImports(content) {
    // This is a simplified version - real implementation would be more sophisticated
    const lines = content.split('\n');
    const importLines = [];
    const otherLines = [];
    let inImports = true;

    for (const line of lines) {
      const trimmed = line.trim();

      if (trimmed.startsWith('import ') || trimmed === '') {
        if (inImports) {
          importLines.push(line);
        }
      } else {
        inImports = false;
        otherLines.push(line);
      }
    }

    // Sort imports alphabetically
    importLines.sort((a, b) => a.localeCompare(b));

    return [...importLines, ...otherLines].join('\n');
  }

  /**
   * Generate optimized hooks
   */
  async generateOptimizedHooks() {
    console.log('ðŸŽ£ Generating optimized hooks...');

    const hooksDir = path.join(this.srcDir, 'hooks');
    if (!fs.existsSync(hooksDir)) {
      fs.mkdirSync(hooksDir, { recursive: true });
    }

    // Create optimized state hook
    const optimizedStateHook = this.generateOptimizedStateHook();
    fs.writeFileSync(path.join(hooksDir, 'useOptimizedState.ts'), optimizedStateHook);

    // Create optimized API hook
    const optimizedApiHook = this.generateOptimizedApiHook();
    fs.writeFileSync(path.join(hooksDir, 'useOptimizedApi.ts'), optimizedApiHook);

    console.log('  âœ“ Generated optimized hooks');
    this.appliedOptimizations.utilityExtractions++;
  }

  /**
   * Generate optimized state hook
   */
  generateOptimizedStateHook() {
    return `/**
 * Optimized State Hook
 *
 * Performance-optimized state management with debouncing and memoization
 */

import { useState, useCallback, useMemo } from 'react';

interface OptimizedStateOptions<T> {
  debounceMs?: number;
  equalityFn?: (a: T, b: T) => boolean;
  onStateChange?: (state: T) => void;
}

export function useOptimizedState<T>(
  initialState: T,
  options: OptimizedStateOptions<T> = {}
) {
  const { debounceMs, equalityFn = Object.is, onStateChange } = options;

  const [state, setState] = useState(initialState);

  const setStateWithCallback = useCallback((newState: T | ((prev: T) => T)) => {
    setState(prevState => {
      const resolvedState = typeof newState === 'function' ? newState(prevState) : newState;

      if (!equalityFn(prevState, resolvedState)) {
        onStateChange?.(resolvedState);
        return resolvedState;
      }

      return prevState;
    });
  }, [equalityFn, onStateChange]);

  const memoizedState = useMemo(() => state, [state]);

  return [memoizedState, setStateWithCallback] as const;
}

export default useOptimizedState;
`;
  }

  /**
   * Generate optimized API hook
   */
  generateOptimizedApiHook() {
    return `/**
 * Optimized API Hook
 *
 * Performance-optimized API calls with caching and deduplication
 */

import { useState, useEffect, useCallback, useRef } from 'react';

interface UseApiOptions<T> {
  cacheTime?: number;
  staleTime?: number;
  retryCount?: number;
  enabled?: boolean;
}

interface ApiState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
  lastFetched: number | null;
}

export function useOptimizedApi<T>(
  key: string,
  fetcher: () => Promise<T>,
  options: UseApiOptions<T> = {}
) {
  const {
    cacheTime = 5 * 60 * 1000, // 5 minutes
    staleTime = 0,
    retryCount = 3,
    enabled = true
  } = options;

  const [state, setState] = useState<ApiState<T>>({
    data: null,
    loading: false,
    error: null,
    lastFetched: null
  });

  const cacheRef = useRef<Map<string, { data: T; timestamp: number }>>(new Map());
  const abortControllerRef = useRef<AbortController | null>(null);

  const fetchData = useCallback(async (forceRefresh = false) => {
    if (!enabled) return;

    // Check cache
    const cached = cacheRef.current.get(key);
    const now = Date.now();

    if (cached && !forceRefresh && (now - cached.timestamp) < cacheTime) {
      setState(prev => ({
        ...prev,
        data: cached.data,
        loading: false,
        error: null
      }));
      return;
    }

    // Cancel previous request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    abortControllerRef.current = new AbortController();

    setState(prev => ({ ...prev, loading: true, error: null }));

    try {
      const data = await fetcher();

      // Check if request was aborted
      if (abortControllerRef.current?.signal.aborted) return;

      // Update cache
      cacheRef.current.set(key, { data, timestamp: now });

      setState({
        data,
        loading: false,
        error: null,
        lastFetched: now
      });
    } catch (error) {
      if (abortControllerRef.current?.signal.aborted) return;

      setState(prev => ({
        ...prev,
        loading: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      }));
    }
  }, [key, fetcher, enabled, cacheTime]);

  useEffect(() => {
    fetchData();

    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [fetchData]);

  const refetch = useCallback(() => {
    fetchData(true);
  }, [fetchData]);

  return {
    ...state,
    refetch
  };
}

export default useOptimizedApi;
`;
  }

  // Helper methods
  getAllFiles(dir, extension) {
    const files = [];

    const traverse = (currentDir) => {
      try {
        const items = fs.readdirSync(currentDir);

        for (const item of items) {
          const fullPath = path.join(currentDir, item);
          const stat = fs.statSync(fullPath);

          if (stat.isDirectory()) {
            if (!item.includes('node_modules') && !item.startsWith('.')) {
              traverse(fullPath);
            }
          } else if (extension.test(fullPath)) {
            files.push(fullPath);
          }
        }
      } catch (error) {
        // Skip directories we can't read
      }
    };

    try {
      traverse(dir);
    } catch (error) {
      // Skip if directory doesn't exist
    }

    return files;
  }

  shouldSkipFile(filePath) {
    const skipPatterns = [
      /\.test\./,
      /\.spec\./,
      /node_modules/,
      /\.d\.ts$/,
      /dist/,
      /build/,
      /coverage/,
      /\/scripts\//
    ];

    return skipPatterns.some(pattern => pattern.test(filePath));
  }
}

// Run the script if executed directly
if (require.main === module) {
  const optimizer = new ApplyOptimizations();
  optimizer.apply().catch(console.error);
}

module.exports = ApplyOptimizations;