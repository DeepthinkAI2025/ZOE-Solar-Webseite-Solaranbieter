import { readFileSync, writeFileSync } from 'fs';
import path from 'path';
import vm from 'vm';
import { fileURLToPath } from 'url';
import { createRequire } from 'module';

const require = createRequire(import.meta.url);
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function loadProductCatalog() {
  const catalogPath = path.resolve(__dirname, '../data/products.generated.ts');
  let content = readFileSync(catalogPath, 'utf8');

  // Strip TypeScript-specific syntax so that we can evaluate the file in Node.
  content = content.replace(/import\s+\{[^}]+\}\s+from\s+'[^']+';\s*/g, '');
  content = content.replace(/export const productCatalog: ProductCatalog =/, 'module.exports =');
  content = content.replace(/} as ProductCatalog;/g, '}');
  content = content.replace(/export default productCatalog;\s*/g, '');

  const sandbox = { module: { exports: {} }, exports: {}, require };
  vm.createContext(sandbox);
  new vm.Script(content, { filename: 'products.generated.ts' }).runInContext(sandbox);

  return sandbox.module.exports;
}

function loadManufacturerSeed() {
  const seedPath = path.resolve(__dirname, '../server/config/manufacturers.js');
  const seedModule = require(seedPath);
  // Support both named and default exports just in case.
  if (Array.isArray(seedModule)) {
    return seedModule;
  }
  if (Array.isArray(seedModule.manufacturerSeed)) {
    return seedModule.manufacturerSeed;
  }
  return [];
}

function main() {
  const productCatalog = loadProductCatalog();
  if (!productCatalog || !Array.isArray(productCatalog.manufacturers)) {
    throw new Error('Unable to load manufacturers from data/products.generated.ts');
  }

  const manufacturerSeed = loadManufacturerSeed();
  const seedMap = new Map(manufacturerSeed.map((entry) => [entry.slug, entry]));

  const livePath = path.resolve(__dirname, '../server/storage/products.live.json');
  const liveRaw = readFileSync(livePath, 'utf8');
  const liveData = JSON.parse(liveRaw);

  if (!Array.isArray(liveData.manufacturers)) {
    liveData.manufacturers = [];
  }

  const existingSlugs = new Set(liveData.manufacturers.map((m) => m.slug));
  const now = new Date().toISOString();

  if (!Array.isArray(liveData.providers)) {
    liveData.providers = [];
  }
  if (!liveData.providers.includes('product-catalog-import')) {
    liveData.providers.push('product-catalog-import');
  }

  const addedManufacturers = [];

  productCatalog.manufacturers.forEach((manufacturer) => {
    if (!manufacturer?.slug || existingSlugs.has(manufacturer.slug)) {
      return;
    }

    const seedEntry = seedMap.get(manufacturer.slug);
    const website = seedEntry?.website || '';

    const products = Array.isArray(manufacturer.products)
      ? manufacturer.products.map((product) => ({
          name: product?.name ?? '',
          description: product?.description ?? '',
          imageUrl: product?.imageUrl ?? '',
          basePrice: Object.prototype.hasOwnProperty.call(product, 'basePrice')
            ? product.basePrice
            : null,
          configurable: Boolean(product?.configurable),
          specs: product?.specs ?? {},
          keyFeatures: Array.isArray(product?.keyFeatures) ? product.keyFeatures : [],
          datasheetUrls: [],
          installationManualUrls: [],
          additionalDocumentUrls: [],
          documents: []
        }))
      : [];

    const newManufacturer = {
      slug: manufacturer.slug,
      name: manufacturer.name ?? manufacturer.slug,
      website,
      logoUrl: manufacturer.logoUrl || '',
      description: manufacturer.description || '',
      whyWeTrust: Array.isArray(manufacturer.whyWeTrust) ? manufacturer.whyWeTrust : [],
      products,
      providersUsed: ['product-catalog-import'],
      syncMeta: {
        lastSyncRun: now,
        source: 'product-catalog-import'
      },
      lastSyncedAt: now,
      migrationMeta: {
        categories: Array.isArray(manufacturer.category) ? manufacturer.category : [],
        source: 'data/products.generated.ts',
        websiteMissing: !website,
        notes: 'Imported from autogenerated front-end catalog. Datasheets, manuals and imagery pending verification.'
      }
    };

    liveData.manufacturers.push(newManufacturer);
    existingSlugs.add(manufacturer.slug);
    addedManufacturers.push({
      name: newManufacturer.name,
      slug: newManufacturer.slug,
      products: newManufacturer.products.length
    });
  });

  if (!addedManufacturers.length) {
    console.log('No new manufacturers were added.');
    return;
  }

  const totalProducts = liveData.manufacturers.reduce(
    (sum, manufacturer) => sum + (Array.isArray(manufacturer.products) ? manufacturer.products.length : 0),
    0
  );

  liveData.generatedAt = now;
  if (liveData.syncMeta && typeof liveData.syncMeta === 'object') {
    liveData.syncMeta.manufacturerCount = liveData.manufacturers.length;
    liveData.syncMeta.lastImportSource = 'product-catalog-import';
    liveData.syncMeta.lastImportAt = now;
  }

  if (!liveData.changeSummary || typeof liveData.changeSummary !== 'object') {
    liveData.changeSummary = {};
  }
  liveData.changeSummary.generatedAt = now;
  liveData.changeSummary.totalManufacturers = liveData.manufacturers.length;
  liveData.changeSummary.totalProducts = totalProducts;
  liveData.changeSummary.manufacturersWithChanges = addedManufacturers.length;
  liveData.changeSummary.manufacturerChanges = addedManufacturers.map((entry) => ({
    manufacturer: entry.name,
    slug: entry.slug,
    changeType: 'added',
    productsAffected: entry.products
  }));

  const changeMessages = [
    `Imported ${addedManufacturers.length} manufacturers from front-end product catalog for consolidation (documentation pending).`
  ];
  if (Array.isArray(liveData.changeSummary.changes)) {
    liveData.changeSummary.changes = changeMessages;
  } else {
    liveData.changeSummary.changes = changeMessages;
  }

  writeFileSync(livePath, JSON.stringify(liveData, null, 2));
  console.log(`Added ${addedManufacturers.length} manufacturers to products.live.json.`);
}

main();
